# Get-CsmeVulnerabilityStatus.ps1
# Originally written by Pyrrh1c 3/14/2020

<#
    .Synopsis
        This script checks the system for vulnerable Intel CSME Firmware. It is a wrapper for the official Intel utility and adds additional functionality.
    .Description
        This script can run in several ways. It can download the utility directly from the Intel website. I can also download the utility from a specified UNC path or a custom HTTP(S) address. The script can also write results to a log file on an SMB share. The vulnerability status will be displayed on the console or piped to the next command in the pipeline window once testing completes. 
    .Parameter TempDir
        The name of the temporary folder created to contain the detection utility. Default is a random 8 digit number. This temporary folder is created in the root of C:\.
    .Parameter TargetFileName
        The name that the downloaded file will be renamed to. Default is "CsmeDetectionTool.zip"
    .Parameter WebUrl
        The URL from which to download the detection tool. Default is the Intel website. It accepts a valid http(s) url.
    .Parameter SmbPath
        This parameter is used to specify that SMB shouled be used to download the file as well as the SMB path to its location.
    .Parameter LogDir
        This parameter accepts a valid file path (local or SMB) and creates or appends to a text file called "results.txt"
    .Parameter LogFileName
        This parameter accepts a valid string which will be used as the log file name.
    .Parameter NoCleanUp
        This parameter tells the script not to clean up the temporary files after completion.
    .Example
        Get-CsmeVulnerabilityStatus

        This downloads the utility from the Intel site, runs it, and prints the results to the console.
    .Example
        Get-CsmeVulnerabilityStatus -Logging \\SERVER01\LogShare\

        This downloads the utility from the Intel site, runs it, and displays the results to the screen while also writing a line with the hostname and results to  the default filename of CsmeScanResults.txt.
    .Example
        Get-CsmeVulnerabilityStatus -Logging \\SERVER01\LogShare\ -LogFileName results.csv

        This downloads the utility from the Intel site, runs it, and displays the results to the screen while also writing a line with the hostname and results to  the specified filename of results.csv
    .Example
        Get-CsmeVulnerabilityStatus -SmbPath \\foo\bar\utility.zip

        This downloads the utility from the specified smb path, runs it, and displays the results to the screen.
    .Example
        Get-CsmeVulnerabilityStatus -WebUrl http://192.168.1.1/utility.zip

        This downloads the utility from the specified HTTP url, runs it, and displays the results to the screen.
    .Link
        http://pyrrh1c.net
    .Link
        https://github.com/pyrrh1c/Get-CsmeVulnerabilityStatus
    .Link
        https://arstechnica.com/information-technology/2020/03/5-years-of-intel-cpus-and-chipsets-have-a-concerning-flaw-thats-unfixable/
    .Link
        https://www.intel.com/content/www/us/en/support/articles/000033416/technologies.html
    .Link
        https://downloadcenter.intel.com/download/28632/Intel-Converged-Security-and-Management-Engine-Intel-CSME-Detection-Tool
    .Notes
        There are more elegant ways to handle temporary file creation. Many organizations (including mine) limit running executables from temporary directories, so I used this method instead.  As with all open source software, you're free to tweak it if you so choose. ;-)
#>

# Defining the parameters for the script to run.
Param(
    [CmdletBinding(DefaultParameterSetName='Web')]

    [Parameter()]
    [String]
    $TempDir=(-join ((48..57) *120 | Get-Random -Count 8 | ForEach-Object{[char]$_})),

    [Parameter()]
    [String]
    $TargetFileName="CsmeDetectionTool.zip",

    [Parameter()]
    # Test the url before proceeding with the script. This prevents garbage being left behind if the script were to crash.
    [ValidateScript({((Invoke-WebRequest -Method Head $_).StatusCode -eq 200)})]
    [String]
    $WebUrl="https://downloadmirror.intel.com/28632/eng/CSME_Version_Detection_Tool_Windows.zip",

    [Parameter(ParameterSetName="SMB")]
    # Test the path before proceeding with the script. This prevents garbage being left behind if the script were to crash.
    [ValidateScript({Test-Path $_})]
    [String]
    $SmbPath,

    [Parameter()]
    # Both Test-Path and casting the path as a string are used for for verifying the LogDir is valid.
    [ValidateScript( {
        try
        {
            $valid = (Test-Path $_) -and ([System.IO.FileInfo]($_)).GetType().Name -eq 'FileInfo'
        }
        catch
        {
            $valid = $false
        }
        finally
        {
            if (-not $valid)
            {
                throw 'Invalid Path specified'
            }
            $valid
        }
    })]
    [String]
    $LogDir,

    [Parameter()]
    [String]
    $LogFileName="CsmeScanResults.txt",

    [Parameter(Mandatory=$false)]
    [Switch]
    $NoCleanUp
)

# Because the utility must run as administrator, we add the corresponding Requires statement.
#Requires -RunAsAdministrator

Function PrepareEnvironment()
{
    Write-Verbose "Create a random directory in C:\ using the name from the TempDir parameter."
    New-Item -ItemType Directory -Path C:\ -Name $TempDir | Out-Null

    Write-Verbose "Move into the newly created working directory."
    Set-Location C:\$TempDir
}

Function WriteResults([String]$Message)
{
    if ($null -ne $LogDir)
    {
        Write-Verbose "Output results."
        Write-Output $Message;
        Write-Verbose "Write results to log file."
        Add-Content -Path "$LogDir\$LogFileName" -Value "$env:computername,$Message"
    }
    else
    {
        Write-Verbose "Output results."
        Write-Output $message
    }
}

Function RunDetection()
{
    Write-Verbose "Unzip the detection utility."
    Expand-Archive -Path $TargetFileName

    Write-Verbose "Change into the detection utility directory"
    Set-Location .\CsmeDetectionTool\DiscoveryTool

    Write-Verbose "Run the detection utility."
    .\CSME-Version-Detection-Tool-console.exe | Out-Null

    Write-Verbose "Print the result to the terminal based on the output of the detection utility."
    Switch ($LASTEXITCODE)
    {
        0 {WriteResults "Platform is not vulnerable."}
        10 {WriteResults "Intel® ME driver is not installed on the platform. Unable to determine platform vulnerability."}
        11 {WriteResults "Error communicating with the Intel® ME driver. Unable to determine platform vulnerability."}
        100 {WriteResults "Platform is vulnerable."}
        101 {WriteResults "Platform is not vulnerable. It has been patched."}
        102 {WriteResults "This platform is no longer supported. No firmware update is available for security issues."}
        200 {WriteResults "Unable to determine platform vulnerability."}
        default {WriteResults "An error occurred while running detection. Detection was not completed."}
    }
}

Function CleanUpEnvironment()
{
    Write-Verbose "Set location to the root of C:"
    Set-Location C:\

    Write-Verbose "Delete the working directory."
    Remove-Item $TempDir -Recurse -Force

    # The following line clears the exit code from the utility. This is mostly for debugging purposes.
    # The $LASTEXITCODE is a powershell Global and persists after script termination.
    # This can cause odd behavior during testing.
    Write-Verbose "Clear last exit code."
    $global:LASTEXITCODE = $null
}

Write-Verbose "Prepare to run the detection tool."
PrepareEnvironment


if($WebUrl)
{
    Write-Verbose "Download the detection tool from the web address."
    Invoke-WebRequest -Uri $WebUrl -OutFile $TargetFileName
}

if($SmbPath)
{
    Write-Verbose "Download the detection tool from the specified SMB path."
    Copy-Item $SmbPath $TargetFileName
}

Write-Verbose "Run the detection tool."
RunDetection

Write-Verbose "lean up the temporary files and foldes, unless the -NoCleanUp parameter is passed."
if (!($NoCleanUp))
{
    Write-Verbose "Cleaning up temporary files and folders."
    CleanUpEnvironment
}

Write-Verbose "Change directory back to where the script was run from."
Set-Location $PSScriptRoot