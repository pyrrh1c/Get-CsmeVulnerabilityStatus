<############################################################################################################
# Get-CsmeVulnerabilityStatus.ps1
#
# Change Log:
# 1.0 - 2020-03-07 - Initial Script Written. Web only for now.
# 1.1 - 2020-03-08 - Got SMB running.
# 1.2 - 2020-03-08 - Minor tweaks to documentation, etc.
# 1.3 - 2020-03-08 - Converted prep and cleanup tasks into functions for better code reuse.
# 1.4 - 2020-03-08 - Added exception handling for invalid SMB paths.
# 1.5 - 2020-03-08 - Added exception handling for invalid Web paths.
# 1.6 - 2020-03-09 - Moving exception handling to param statements instead of script code. Half way there...
# 1.7 - 2020-03-09 - Got all parameter validation rules working.
# 2.0 - 2020-03-09 - Stable. Adding a unit testing script.
# 2.1 - 2020-03-10 - Enabled logging.
# 2.2 - 2020-03-10 - Neatened up a few minor things. Updated To Do list.
# 2.3 - 2020-03-11 - Moved output to its own function.
# 2.4 - 2020-03-11 - Fixed the output code. Was calling Write-Output instead of the actual internal function.
# 2.5 - 2020-03-12 - Multiple style and code-flow changes based on feeback from Reddit.
# 3.0 - 2020-03-13 - Included more changes from Reddit feedback.
#
# To-Do:
# Add logging options.
# Enable the use of other file names for logging.
# Add verbose output.
############################################################################################################>

<#
    .Synopsis
        This script checks the system for vulnerable Intel CSME Firmware. It is a wrapper for the official Intel utility and adds additional functionality.
    .Description
        This script can run in several ways. It can download the utility directly from the Intel website. I can also download the utility from a specified UNC path or a custom HTTP(S) address. The script can also write results to a log file on an SMB share. The vulnerability status will be displayed on the console or piped to the next command in the pipeline window once testing completes. 
    .Parameter TempDir
        The name of the temporary folder created to contain the detection utility. Default is a random 8 digit number. This temporary folder is created in the root of C:\.
    .Parameter TargetFileName
        The name that the downloaded file will be renamed to. Default is "CsmeDetectionTool.zip"
    .Parameter WebUrl
        The URL from which to download the detection tool. Default is the Intel website. It accepts a valid http(s) url.
    .Parameter SmbPath
        This parameter is used to specify that SMB shouled be used to download the file as well as the SMB path to its location.
    .Parameter LogDir
        This parameter accepts a valid file path (local or SMB) and creates or appends to a text file called "results.txt"
    .Parameter NoCleanUp
        This parameter tells the script not to clean up the temporary files after completion.
    .Example
        Get-CsmeVulnerabilityStatus
    .Example
        Get-CsmeVulnerabilityStatus -Logging \\SERVER01\LogShare\
    .Example
        Get-CsmeVulnerabilityStatus -SmbPath \\foo\bar\utility.zip
    .Example
        Get-CsmeVulnerabilityStatus -WebUrl http://192.168.1.1/utility.zip
    .Link
        https://arstechnica.com/information-technology/2020/03/5-years-of-intel-cpus-and-chipsets-have-a-concerning-flaw-thats-unfixable/
    .Link
        https://www.intel.com/content/www/us/en/support/articles/000033416/technologies.html
    .Link
        https://downloadcenter.intel.com/download/28632/Intel-Converged-Security-and-Management-Engine-Intel-CSME-Detection-Tool
    .Notes
        There are more elegant ways to handle temporary file creation. Many organizations limit access to temp files by executables, so I used this method instead.
#>

# Defining the parameters for the script to run.
Param(
    [CmdletBinding(DefaultParameterSetName='Web')]

    # There are cleaner ways to do this. 
    # Many organizations has special restrictions on temp folders and executable files, so I did this.
    [Parameter()]
    [String]
    $TempDir=(-join ((48..57) *120 | Get-Random -Count 8 | ForEach-Object{[char]$_})),

    [Parameter()]
    [String]
    $TargetFileName="CsmeDetectionTool.zip",

    [Parameter()]
    # Test the url before proceeding with the script. This prevents garbage being left behind if the script were to crash.
    [ValidateScript({((Invoke-WebRequest -Method Head $_).StatusCode -eq 200)})]
    [String]
    $WebUrl="https://downloadmirror.intel.com/28632/eng/CSME_Version_Detection_Tool_Windows.zip",

    [Parameter(ParameterSetName="SMB")]
    # Test the path before proceeding with the script. This prevents garbage being left behind if the script were to crash.
    [ValidateScript({Test-Path $_})]
    [String]
    $SmbPath,

    [Parameter()]
    # Both Test-Path and casting the path as a string are used for for verifying the LogDir is valid.
    [ValidateScript( {
        try
        {
            $valid = (Test-Path $_) -and ([System.IO.FileInfo]($_)).GetType().Name -eq 'FileInfo'
        }
        catch
        {
            $valid = $false
        }
        finally
        {
            if (-not $valid) 
            { 
                throw 'Invalid Path specified' 
            }
            $valid
        }
    })]
    [String]
    $LogDir,

    [Parameter(Mandatory=$false)]
    [Switch]
    $NoCleanUp
)

# Because the utility must run as administrator, we add the corresponding Requires statement.
#Requires -RunAsAdministrator

Function PrepareEnvironment()
{
    #Create a random directory in C:\ using the name from the TempDir parameter.
    New-Item -ItemType Directory -Path C:\ -Name $TempDir | Out-Null

    # Move into the newly created working directory.
    Set-Location C:\$TempDir
}

Function WriteResults([String]$Message)
{
    if ($null -ne $LogDir)
    {
        Write-Output $Message; 
        Add-Content -Path "$LogDir\CsmeResults.txt" -Value "$env:computername,$Message"
    }
    else
    {
        Write-Output $message
    }
}

Function RunDetection()
{
    # Unzip the detection utility.
    Expand-Archive -Path $TargetFileName

    # Change into the detection utility directory.
    Set-Location .\CsmeDetectionTool\DiscoveryTool

    # Run the detection utility.
    .\CSME-Version-Detection-Tool-console.exe | Out-Null

    # Print the result to the terminal based on the output of the detection utility.
    Switch ($LASTEXITCODE)
    {
        # Write-Host is ugly. This should be something more elegant...
        0 {WriteResults "Platform is not vulnerable."}
        10 {WriteResults "Intel® ME driver is not installed on the platform. Unable to determine platform vulnerability."}
        11 {WriteResults "Error communicating with the Intel® ME driver. Unable to determine platform vulnerability."}
        100 {WriteResults "Platform is vulnerable."}
        101 {WriteResults "Platform is not vulnerable. It has been patched."}
        102 {WriteResults "This platform is no longer supported. No firmware update is available for security issues."}
        200 {WriteResults "Unable to determine platform vulnerability."}
        default {WriteResults "An error occurred while running detection. Detection was not completed."}
    }
}

Function CleanUpEnvironment()
{
    # Set location to the root of C:
    Set-Location C:\

    # Delete the working directory.
    Remove-Item $TempDir -Recurse -Force

    # The following line clears the exit code from the utility. This is mostly for debugging purposes.
    # The $LASTEXITCODE is a powershell Global and persists after script termination.
    # Thisc can cause odd behavior during testing.
    $global:LASTEXITCODE = $null
}

# Prepare to run the detection tool.
PrepareEnvironment

# The script was run with the DownloadFromWeb parameter.
if($WebUrl)
{
    # Download the detection tool from the web address
    Invoke-WebRequest -Uri $WebUrl -OutFile $TargetFileName
}

# The script was run with the DownloadFromSmb parameter.
if($SmbPath)
{
    # Download the detection tool from the specified SMB path.
    Copy-Item $SmbPath $TargetFileName
}

# Run the detection tool.
RunDetection

# Clean up the temporary files and foldes, unless the -NoCleanUp parameter is passed.
if (!($NoCleanUp))
{
    CleanUpEnvironment
}

# Change directory back to where the script was run from. (In case you launched it from a command prompt.)
Set-Location $PSScriptRoot